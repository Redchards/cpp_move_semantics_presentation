<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="description" content="A deep dive into the move semantics of modern C++">
        <meta name="author" content="Loic URIEN">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <title>Deciphering C++'s move semantics</title>

        <link rel="stylesheet" href="dist/reset.css">
        <link rel="stylesheet" href="dist/reveal.css">
        <link rel="stylesheet" href="dist/theme/solarized_custom.css">

        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="plugin/highlight/tomorrow-night-eighties.css">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-auto-animate>
                    <h3>Deciphering C++'s move semantics</h3>
                    <img src="img/move_semantics_logo.png" alt="main-logo" width="275" height="300" />
                    <div class="fragment fade-in">
                        <em>it's not all as it seems...</em>
                    </div>
                </section>
                <section data-auto-animate>
                    <h3>Deciphering C++'s move semantics</h3>
                    <img src="img/move_semantics_logo.png" alt="main-logo" width="275" height="300" />
                    <div>
                        <em>Let's get started</em>
                    </div>
                </section>
                <section>
                    <section>
                        <h3>A (way too) simple model</h3>
                        <img src="img/simplistic_memory_model.png" alt="simplistic-memory-logo" width="575" height="300" />
                        <p>Simple, right?</p>
                        <p>We either move...</p>
                        <p>...or we copy! (yay)</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>The silver bullet?</h3>
                        <p>With move semantics : </p>
                        <ul style="display: block; text-align: left;">
                            <li class="fragment fade-in">we never copy whole objects</li>
                            <li class="fragment fade-in">we know that the compiler will optimize our memory operations</li>
                            <li class="fragment fade-in">we actually move memory around (std::move ftw)</li>
                        </ul>
                    </section>
                    <section data-auto-animate>
                        <h3>Not really...</h3>
                        <p>With move semantics : </p>
                        <ul style="display: block; text-align: left;">
                            <li class="fragment strike">we never copy whole objects</li>
                            <li class="fragment strike">we know that the compiler will optimize our memory operations</li>
                            <li class="fragment strike">we actually move memory around (std::move ftw)</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>It's not all as it seems</h3>
                        <ul style="display: block; text-align: left;">
                            <li class="fragment fade-in">Move semantics are only that, <b>semantics</b></li>
                            <li class="fragment fade-in">They do not induce any inherent <em>move</em> operation</li>
                            <li class="fragment fade-in"><b>They can also be quite dangerous if not used carefully</b> (we shall see why)</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>lvalue reference, rvalue reference, oh my!</h3>

                        <p class="fragment fade-in" style="display: block; text-align: left;">Most C++ programmers are familiar with the concept of "lvalue" and "rvalue"</p>
                        <ul style="display: block; text-align: left;">
                            <li class="fragment fade-in">an lvalue is a "named value"</li>
                            <li class="fragment fade-in">an lvalue reference is a reference on an lvalue, indicated by &</li>
                            <li class="fragment fade-in">an rvalue is an "unnamed value"</li>
                            <li class="fragment fade-in">an rvalue reference is a reference on a rvalue, indicated by &&</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Likely reaction to that information</h3>
                        <img src="img/roll_eye_meme.png" alt="simplistic-memory-logo" width="575" height="500" />
                    </section>
                </section> 
                <section>
                    <section>
                        <h3>No magic involved!!</h3>
                        <p>If the concept seems trivial to you, it's because it is! Whether a reference is an lvalue-reference or rvalue-reference will only affect the overload resolution, and nothing else!</p>
                        <p>Caveat : constant lvalue references can bind to rvalues.</p>
                    </section>
                </section> 
                <section>
                    <section data-auto-animate>
                        <h3>Illustration</h3>
                        <img src="img/move_anim_1_tsp.png" alt="move-anim-1" width="650" height="450" />
                    </section>
                    <section data-auto-animate>
                        <h3>Illustration</h3>
                        <img src="img/move_anim_2_tsp.png" alt="move-anim-2" width="650" height="450" />
                    </section>
                    <section data-auto-animate>
                        <h3>Illustration</h3>
                        <img src="img/move_anim_3_tsp.png" alt="move-anim-3" width="650" height="450" />
                    </section>
                    <section data-auto-animate>
                        <h3>Illustration</h3>
                        <img src="img/move_anim_3_tsp.png" alt="move-anim-3" width="650" height="450" />
                        <p>Let's see some code</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=0-15><script type="text/template">
                            class CopyConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                CopyConstructible(const CopyConstructible& other) 
                                : buffer{ new BigObject(other.buffer) } 
                                {}

                                ~CopyConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            CopyConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = obj; // copy
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            CopyConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // copy
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=17-25><script type="text/template">
                            class CopyConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                CopyConstructible(const CopyConstructible& other) 
                                : buffer{ new BigObject(other.buffer) } 
                                {}

                                ~CopyConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            CopyConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = obj; // copy
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            CopyConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // copy
                            // :(
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <p>Two copies. Copy elision can happen but is not guaranteed...</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=17-25><script type="text/template">
                            class CopyConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                CopyConstructible(const CopyConstructible& other) 
                                : buffer{ new BigObject(other.buffer) } 
                                {}

                                ~CopyConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            CopyConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = obj; // copy
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            CopyConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // copy
                            // :(
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <p>Maybe we can share the resource?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=0-15><script type="text/template">
                            class CopyConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                CopyConstructible(const CopyConstructible& other) 
                                : buffer{ new BigObject(other.buffer) } 
                                {}

                                ~CopyConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            CopyConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = obj; // copy
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            CopyConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // copy
                            // :(
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <p>Maybe we can share the resource?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=0-15><script type="text/template">
                            class CopyConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                CopyConstructible(const CopyConstructible& other) 
                                : buffer{ other.buffer } 
                                {}

                                ~CopyConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            CopyConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = obj; // copy
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            CopyConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // copy
                            // :(
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <p>That's not really what we want though...</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=0-16><script type="text/template">
                            class CopyConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                CopyConstructible(const CopyConstructible& other) 
                                : buffer{ other.buffer } 
                                {}

                                // What if the pointer is shared?
                                ~CopyConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            CopyConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = obj; // copy
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            CopyConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // copy
                            // :(
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=0-18><script type="text/template">
                            class MoveConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                MoveConstructible(MoveConstructible&& other) 
                                : buffer{ other.buffer } 
                                {
                                    // We're stealing the resource, we want sole ownership
                                    other.buffer = nullptr; 
                                }

                                ~MoveConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            MoveConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = obj; // copy
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            MoveConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // copy
                            // :(
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=20-29><script type="text/template">
                            class MoveConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                MoveConstructible(MoveConstructible&& other) 
                                : buffer{ other.buffer } 
                                {
                                    // We're stealing the resource, we want sole ownership
                                    other.buffer = nullptr; 
                                }

                                ~MoveConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            MoveConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = obj; // copy
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            MoveConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // copy
                            // :(
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers=20-29><script type="text/template">
                            class MoveConstructible
                            {
                            public:
                            // Rule of 5
                            // other copy/move constructors/operators and destructor 
                            // are implicitely deleted
                                MoveConstructible(MoveConstructible&& other) 
                                : buffer{ other.buffer } 
                                {
                                    // We're stealing the resource, we want sole ownership
                                    other.buffer = nullptr; 
                                }

                                ~MoveConstructible() { if (buffer) delete buffer; }

                            private:
                                BigObject* buffer;
                            };

                            MoveConstructible process(const CopyConstructible& obj)
                            {
                                auto modified_obj = std::move(obj); // move constructor
                                // do something with our modified_obj
                                return modified_obj; // assume NRVO
                            }

                            MoveConstructible c1 = make_big_copy_constructible_object(...);
                            auto c2 = process(c1); // move constructor
                            // :)
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <img src="img/move_potatoes.png" alt="move-potatoes" width="875" height="500" />
                    </section>
                    <section data-auto-animate>
                        <h3>Introductory example</h3>
                        <p>Warning : if you have not defined a move constructor/operator, the copy constructor/operator will be called</p>
                        <img src="img/move_potatoes.png" alt="move-potatoes" width="875" height="500" />
                    </section>
                </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>What is std::move, exactly?</h3>
                        <p style="display: block; text-align: left;">Hmmm...</p>
                        <img src="img/fake_std_move.png" alt="not-std-move" width="1675" height="350" />
                    </section>
                    <section data-auto-animate>
                        <h3>What is std::move, exactly?</h3>
                        <p style="display: block; text-align: left;">Yeah, this one!</p>
                        <img src="img/actual_std_move.png" alt="yes-std-move" width="1675" height="250" />
                    </section>
                    <section data-auto-animate>
                        <h3>What is std::move, exactly?</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<class T>
                            auto std::move(T&& t)
                            {
                                // Too difficult to write here
                                // Insert crazy guru code that no sane person can comprehend
                            }
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>What is std::move, exactly?</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<class T>
                            auto std::move(T&& t)
                            {
                                // Or... maybe not?
                                return static_cast<std::remove_reference_t<T>&&>(t);
                            }
                        </script></code></pre>
                        <p class="fade-in">This is a valid implementation</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Small interlude</h3>
                        <img src="img/interlude_potato.png" alt="interlude_potato" width="450" height="450" />
                    </section>
                    <section data-auto-animate>
                        <h3>Small interlude</h3>
                        <p style="display: block; text-align: left;">What have we learned?</p>
                        <ul style="display: block; text-align: left;">
                            <li class="fragment fade-in"><code class="language-cpp">std::move</code> is not magic, it's a simple cast to rvalue reference</li>
                            <li class="fragment fade-in">we implement the actual move ourselves, no compiler magic here!</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>What of PODs?</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<size_t dimension>
                            struct StaticSquareMatrix
                            {
                                using row_t = std::array<double, dimension>;
                                std::array<row_t, dimension> data;
                            };
                            // dimension * dimension * sizeof(double) bytes
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>What of PODs?</h3>
                        <p style="display: block; text-align: left;">How do you move such an object?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<size_t dimension>
                            struct StaticSquareMatrix
                            {
                                using row_t = std::array<double, dimension>;
                                std::array<row_t, dimension> data;
                            };
                            // dimension * dimension * sizeof(double) bytes
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>What of PODs?</h3>
                        <p style="display: block; text-align: left;">How do you move such an object?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<size_t dimension>
                            struct StaticSquareMatrix
                            {
                                using row_t = std::array<double, dimension>;
                                std::array<row_t, dimension> data;
                            };
                            // dimension * dimension * sizeof(double) bytes
                        </script></code></pre>
                        <p style="display: block; text-align: left;">Remember, <code class="language-cpp">std::move</code> will not actually <em>move</em> anything for you</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Remember?</h3>
                        <img src="img/move_anim_1_tsp.png" alt="move-anim-1" width="650" height="450" />
                    </section>
                    <section data-auto-animate>
                        <h3>Remember?</h3>
                        <img src="img/move_anim_2_tsp.png" alt="move-anim-2" width="650" height="450" />
                    </section>
                    <section data-auto-animate>
                        <h3>Remember?</h3>
                        <img src="img/move_anim_3_tsp.png" alt="move-anim-3" width="650" height="450" />
                    </section>
                    <section data-auto-animate>
                        <h3>Remember?</h3>
                        <img src="img/move_potatoes.png" alt="move-potatoes" width="875" height="500" />
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>So?</h3>
                        <p style="display: block; text-align: left;">Where is the pointer to be moved here?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<size_t dimension>
                            struct StaticSquareMatrix
                            {
                                using row_t = std::array<double, dimension>;
                                std::array<row_t, dimension> data;
                            };
                            // dimension * dimension * sizeof(double) bytes
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>So?</h3>
                        <p style="display: block; text-align: left;">Where is the pointer to be moved here?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<size_t dimension>
                            struct StaticSquareMatrix
                            {
                                using row_t = std::array<double, dimension>;
                                std::array<row_t, dimension> data;
                            };
                            // dimension * dimension * sizeof(double) bytes
                        </script></code></pre>
                        <p style="display: block; text-align: left;">No dice, moving won't do us good here...</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Quiz time!</h3>
                        <p style="display: block; text-align: left;">What is the output of each call?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            // ...
                            Blob blobby{};

                            process(blobby);             // ? 
                            process(&blobby);            // ?
                            process(Blob{});             // ?
                            process(std::move(blobby));  // ?
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Quiz time!</h3>
                        <p style="display: block; text-align: left;">What is the output of each call?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            // ...
                            Blob blobby{};

                            process(blobby);             // lvalue ref
                            process(&blobby);            // ?
                            process(Blob{});             // ?
                            process(std::move(blobby));  // ?
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Quiz time!</h3>
                        <p style="display: block; text-align: left;">What is the output of each call?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            // ...
                            Blob blobby{};

                            process(blobby);             // lvalue ref
                            process(&blobby);            // pointer
                            process(Blob{});             // ?
                            process(std::move(blobby));  // ?
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Quiz time!</h3>
                        <p style="display: block; text-align: left;">What is the output of each call?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            // ...
                            Blob blobby{};

                            process(blobby);             // lvalue ref
                            process(&blobby);            // pointer
                            process(Blob{});             // rvalue ref
                            process(std::move(blobby));  // ?
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Quiz time!</h3>
                        <p style="display: block; text-align: left;">What is the output of each call?</p>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            // ...
                            Blob blobby{};

                            process(blobby);             // lvalue ref
                            process(&blobby);            // pointer
                            process(Blob{});             // rvalue ref
                            process(std::move(blobby));  // rvalue ref
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Quiz time!</h3>
                        <p style="display: block; text-align: left;">What is the output of each call?</p>
                        <a href="https://godbolt.org/z/nhE9ExGGe">Runnable demo</a>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            // ...
                            Blob blobby{};

                            process(blobby);             // lvalue ref
                            process(&blobby);            // pointer
                            process(Blob{});             // rvalue ref
                            process(std::move(blobby));  // rvalue ref
                        </script></code></pre>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Quiz time encore!</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            void consume(Blob&& b) { process(b); }

                            // ...
                            Blob blobby{};

                            consume(std::move(blobby)); // ?
                            consume(Blob{});            // ?
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Quiz time encore!</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            void consume(Blob&& b) { process(b); }

                            // ...
                            Blob blobby{};

                            consume(std::move(blobby)); // lvalue ref
                            consume(Blob{});            // ?
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Quiz time encore!</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            struct Blob
                            {};

                            void process(Blob*)  { std::cout << "pointer"    << std::endl; }
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            void consume(Blob&& b) { process(b); }

                            // ...
                            Blob blobby{};

                            consume(std::move(blobby)); // lvalue ref
                            consume(Blob{});            // lvalue ref
                        </script></code></pre>
                        <p class="fragment fade-in">Wait, why?</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>It's in the name</h3>
                        <p>We've got an rvalue-reference, meaning that : </p>
                        <ul style="display: block; text-align: left;">
                            <li class="fragment fade-in">The value it's bound to is an rvalue, but it's not itself an rvalue</li>
                            <li class="fragment fade-in">An rvalue-ref binds to an rvalue, but it itself has a name, and is thus an lvalue</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Let's move on...</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            void consume(Blob&& b) { process(b); }

                            // ...
                            Blob blobby{};

                            consume(std::move(blobby)); // lvalue ref
                            consume(Blob{});            // lvalue ref
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Let's move on...</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            void process(Blob&)  { std::cout << "lvalue ref" << std::endl; }
                            void process(Blob&&) { std::cout << "rvalue ref" << std::endl; }

                            void consume(Blob&& b) { process(std::move(b)); }

                            // ...
                            Blob blobby{};

                            consume(std::move(blobby)); // rvalue ref
                            consume(Blob{});            // rvalue ref
                        </script></code></pre>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Learning to let go</h3>
                        <p>To pass an rvalue reference to a function or method is to relinquish the ownership of the variable</p>
                        <p>Using a value after having "moved" it is called a use-after-move, and is <b style="color:red">undefined behavior</b></p>
                    </section>
                    <section data-auto-animate>
                        <h3>Learning to move on...</h3>
                        <img src="img/sad_empty_potato.png" alt="move-potatoes" width="400" height="400" />
                        <p><em>An actual depiction of a moved value</em></p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Performance...</h3>
                        <p>Move semantics are often thought of as a tool for performance...</p>
                    </section>
                    <section data-auto-animate>
                        <h3>Ownership!</h3>
                        <p>Move semantics are often thought of as a tool for performance...</p>
                        <p>While true, it's first and foremost an great tool to model ownership</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>std::auto_ptr and the 40 thieves</h3>
                        <p>Once upon a time, there was a so-called smart pointer, bearing the modest, although nondescript name, of std::auto_ptr</p>
                        <p>Its story went a bit like that :</p>
                    </section>
                    <section data-auto-animate>
                        <h3>std::auto_ptr and the 40 thieves</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<class T>
                            class auto_ptr
                            {
                            public:
                                auto_ptr() = default;
                                auto_ptr(T* raw_ptr) : ptr_{ raw_ptr } {}
                                auto_ptr(const auto_ptr& other) : ptr_{ other.ptr_ }
                                {
                                    other.ptr_ = nullptr;
                                }

                                ~auto_ptr() { delete ptr_; }

                            private:
                                T* ptr_;
                            };
                        </script></code></pre>
                        <p class="fragment fade-in">In a real implementation, you'd use <code class="language-cpp">std::decay_t&ltT&gt*</code></p>
                    </section>
                    <section data-auto-animate>
                        <h3>std::auto_ptr and the 40 thieves</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<class T>
                            class auto_ptr
                            {
                            public:
                                auto_ptr() = default;
                                auto_ptr(T* raw_ptr) : ptr_{ raw_ptr } {}
                                auto_ptr(const auto_ptr& other) : ptr_{ other.ptr_ }
                                {
                                    other.ptr_ = nullptr; // HEY!!! THIEF!!!
                                }

                                ~auto_ptr() { delete ptr_; }

                            private:
                                T* ptr_;
                            };
                        </script></code></pre>
                        <p class="fragment fade-in">Without semantics, no way to express this transfer of ownership...</p>
                    </section>
                    <section data-auto-animate>
                        <h3>std::unique_ptr the gentleman thief</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            template<class T>
                            class unique_ptr
                            {
                            public:
                                unique_ptr() = default;
                                unique_ptr(T* raw_ptr) : ptr_{ raw_ptr } {}
                                unique_ptr(unique_ptr&& other) : ptr_{ other.ptr_ }
                                {
                                    other.ptr_ = nullptr; // Allow me to steal from you :)
                                }

                                ~unique_ptr() { delete ptr_; }

                            private:
                                T* ptr_;
                            };
                        </script></code></pre>
                        <p class="fragment fade-in">Clearly defined ownership transfer through semantics!</p>
                        <p class="fragment fade-in">Although we cannot ensure no use after free...</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>What about...</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            class Foo { ... };
                            
                            Foo produce_foo()
                            {
                                Foo foo{};
                                // ...
                                return std::move(foo); // FAST!
                            }
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>What about...</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            class Foo { ... };
                            
                            Foo produce_foo()
                            {
                                Foo foo{};
                                // ...
                                return std::move(foo); // Oops... 
                            }
                        </script></code></pre>
                        <p class="fragment fade-in">We're actually breaking the RVO here...</p>
                    </section>
                    <section>
                        <h3>RVO?</h3>
                        <p class="fragment fade-in" style="display: block; text-align: left;">Return Value Optimization</p>
                        <ul style="display: block; text-align: left;">
                            <li class="fragment fade-in">if a named lvalue is returned, the compiler will elide the copy and directy use the lvalue's memory</li>
                            <li class="fragment fade-in">if a value is initialized from a prvalue, the compiler will also elide the copy and directly use the prvalue's memory</li>
                            <li class="fragment fade-in">if no RVO can be used, the compiler is guaranteed to try to move the returned value</li>
                        </ul>
                        <p class="fragment fade-in" style="display: block; text-align: left;">Using <code class="language-cpp">std::move</code> on a returned value will always result in the worst case scenario, we're pessimistic!</p>
                    </section>
                    <section>
                        <h3>Value Categories : prvalue, glvalue, xvalue...</h3>
                        <p class="fragment fade-in" style="display: block; text-align: left;">Kind of <a href="https://en.cppreference.com/w/cpp/language/value_category">out of the scope of this presentation</a></p> 
                    </section>
                    <section>
                        <h3>Value Categories : prvalue</h3>
                        <p style="display: block; text-align: left;">Focusing on prvalues:</p>
                        <p>A prvalue ("pure" rvalue) is an expression that initializes an object, often from the return of a function that are not lvalues (refs)</p>
                        <pre class="fragment fade-in" data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            auto f = produce_foo();
                        </script></code></pre>
                    </section>
                    <section>
                        <h3>Copy elision</h3>
                        <p class="fragment fade-in" style="display: block; text-align: left;">The name "copy elision" is actually fairly misleading. From the standard's point of view, in the cases where it applies, it means that no copy can possibly take place. So, in that sense, no copy is ever elided, no copy was ever supposed to exist.</p>
                        <p class="fragment fade-in" style="display: block; text-align: left;">However, compilers are not always fully standard compliant</p>
                    </section>
                    <section data-auto-animate>
                        <h3>Taking advantage of the RVOs</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            class Foo { ... };
                            
                            Foo produce_foo()
                            {
                                Foo foo{};
                                // ...
                                return std::move(foo); // Oops... 
                            }
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>Taking advantage of the RVOs</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            class Foo { ... };
                            
                            Foo produce_foo()
                            {
                                Foo foo{};
                                // ...
                                return foo; // NRVO will likely trigger
                            }
                        </script></code></pre>
                        <p class="fragment fade-in" style="display: block; text-align: left;">GCC actually has a warning about "pessimizing moves" such as this one</p>
                    </section>
                    <section data-auto-animate>
                        <h3>To sum it up</h3>
                        	<table>
                            <thead><tr>
                                <th>Return Statement</th>
                                <th>RVO</th>
                                <th>No RVO</th>
                            </tr></thead>
                            <tbody><tr>
                                <td><code class="language-cpp">return foo</code></td>
                                <td>no copy or move, memory reuse</td>
                                <td>guaranteed move</td>
                            </tr>
                            <tr>
                                <td><code class="language-cpp">return std::move(foo)</code></td>
                                <td style="color:red"><b>IMPOSSIBLE!</b></td>
                                <td>explicit move</td>
                            </tr></tbody>
                            </table>
                        </script></code></pre>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>rvalue refs and constness</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            void consume(const Foo&& foo); // ?
                        </script></code></pre>
                    </section>
                    <section data-auto-animate>
                        <h3>rvalue refs and constness</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            void consume(const Foo&& foo); // We *consume* a const value...
                        </script></code></pre>
                        <p class="fragment fade-in">The semantics here don't really make sense</p>
                    </section>
                </section>
                    <section data-auto-animate>
                        <h3>Don't lie!</h3>
                        <pre data-id="code-animation"><code class="language-cpp" data-trim data-line-numbers><script type="text/template">
                            class Foo { ... };
                        
                            void consume_food(Foo&& foo){ ... }
                            
                            void borrow_foo(Foo& foo)
                            {
                                // ...
                                // We lied, we're stealing, not borrowing
                                consume_foo(std::move(foo));
                            }
                        </script></code></pre>
                        <p class="fragment fade-in" style="display: block; text-align: left;">While it's technically valid C++, breaking the contract with our user is <b>greatly</b> discouraged</p>
                        <p class="fragment fade-in" style="display: block; text-align: left;">Move semantics are a tool to define ownership, so use it as such!</p>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Main Takeways</h3>
                        <ul style="display: block; text-align: left;">
                            <li class="fragment fade-in">std::move is a cast, nothing else</li>
                            <li class="fragment fade-in">we don't actually move anything</li>
                            <li class="fragment fade-in">performance increase through "stealing" pointer to resources</li>
                            <li class="fragment fade-in">provide a way to define ownership through semantics</li>
                            <li class="fragment fade-in">std::move in a return statement is pessimizing</li>
                            <li class="fragment fade-in">beware of use-after-move!!!</li>
                            <li class="fragment fade-in">copies are not (necessarily) your enemy</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section data-auto-animate>
                        <h3>Thank your for your attention!</h3>
                        <div class="fragment fade-in">
                            <p>Any question?</p>
                            <img src="img/happy_potato.png" alt="happy-potato" />
                        </div>
                    </section>
                </section>
            </div>
        </div>

        <script src="dist/reveal.js"></script>
        <script src="plugin/notes/notes.js"></script>
        <script src="plugin/markdown/markdown.js"></script>
        <script src="plugin/highlight/highlight.js"></script>
        <script>
            // More info about initialization & config:
            // - https://revealjs.com/initialization/
            // - https://revealjs.com/config/
            Reveal.initialize({
                hash: true,

                // Learn about plugins: https://revealjs.com/plugins/
                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
        </script>
    </body>
</html>
